# Angular Overview

## File Structure

Type Script is automatically compiled/Converted to js by Angular Cli.

index.html : Contains `<app-root>` that is the entry point for our angular project.

polyfills.ts : Used for older browser that might not support the newer functions of javascript.

### Module

Split code into files that work independenly of each other.

app.module.ts : This file is used to register all the component that we will use in our project.

### BootStrap

AppModule bootstrap the angular application in the enviroment.ts file.
When in this file we set the app to production, angular performs a lot of optimization that will make the code faster, where code clearity is not necessary.

## Decorators

What are decorator exactly?

Example : `@Component`

```ts
//Here we defince the decorator function that will be used to modify the below function
function log(target, name, descriptor){
    console.log(traget, name, desctiptor);

    //This assigns the value of the original function to original.
    const original = descriptor.value

    //This will run the original function. This itself is a call to the function and the function will run twice whe  the function  is actually called.
    //Even so it will not inclued changes that are dont below as we have not yet returned the function value.
    //Change --1
    //original();

    //Change --2
    /*
    * Here we have changed the the original function itself. If we have this codeblock, the original function will never excute.
    * Instead we will have this defined function execute when the function below is called.
    */
    // descriptor.value = function(){
    //     console.log("This function was hacked!")
    // }

    //We will create a useful function that will work as a logger to console function.
    //Once we create this function the below function will not be executed. This function however uses the values for the below function.
    descriptor.value = function(...args){
        console.log("Arguments "), args, "were passed");
        //The .apply function used to apply this form the original function to the updated function.
        const result = original.apply(this, args);
        console.log("The result of the function is ", result);
        return result;
    }

    //We return the changed function.
    return descriptor;
}

export class AppComponent{
    title = 'app';
    constructor(){
        console.log('This statement was generated by constructor');
        this.aSimpleMethod(5);
    }

    //@log is the decorator for the function.
    @log
    aSimpleMethod(a){
        return a*a
    }
 }

```

### Class Decorator

Example : @Component.

Decorators can be applied to class, but they have to be immediately above the class name.
Multiple decorators could be added to classes.

Note : The class decorator will be fired before the class is exported or used.

```ts

//This will print the class a function as classes in javascript are basically prototype functions.
//Change --1
// function classFunction(classAsFunction){
//     console.log(classAsFunction);
// }

//Change --2
function classFunction(className){
    console.log(className);
    retrun (...args) => {
        console.log("Arguments passed to this class constructor are : "  + args);
        return new className(...args);
    }
}

@classFunction
class myExampleClass{
    constructor(arg1, arg2){
        console.log("Constructor Fired!")
    }
}

const myClass = new myExampleClass(5, 10);
```

## Lifecycle Hooks : Introduction

1. OnChanges : Every time there is a change lets say input property.

2. OnInit : Whenever a componet is initailized. The code that is in the oninit method will be fired or invoked only once.

3. DoCheck : Fired by angular when it thinks there was a change.

4. AfterContentInit :

5. AfterContentCheck :

6. AfterViewInit :

7. OnDestroy : Called when some componet is destroied or removed.

## Components

### What is Component

Lets take the example of header for a page. This header will be then usable on multiple pages. This is thus called as component is Angular.

app.component.ts contains all the logic for the component that we create.

Create a new component : `ng generate component hello`.

When we create a new component Angular cli will automatically add the component name to app.modile.ts in the @NgModule -> declarations array.

This is where all the component that we create will automatically be added or we will need to add if we add a component manually. This will make angular aware of all the component that are being used by us to render them as needed.

We after creating a component we need to import the component in the other component.ts file of the component that uses the custom component.

## Interpolation

`{{ myVar }}` : This represents the javascript value in the html file.

Not all javascript expression can be used in this. For example bitwise operation can be performed in the interpolation.

This is because Angular has Pipes that perform some functions with `|`.

Also functions should not be called from Interpolation on the html page as they are called multilpe times whenever change is detected on the page.

## Data Binding

The following is what sets the attribute value of the text box to the value of the variable.

```html
<input type="text" [value]="myVariable" />
```

There is also a value property to the textbox itself. If we use the following code we bind the data to the value of the text box. The above code is recommended even though the following code appears to work similarly.

```html
<input type="text" value="{{myVariable}}" />
```

### Source to Target

`()` : Round brackets are used for traget to source databinding.

```html
<button (click)="callMyFunction()"></button>
```

The callMyFunction is defined in the component.ts file of the component that is being used.

### Two way Data Binding

Angualarjs use to come with Two way Data Binding inbuild but Angualar 2 onwards does not come with it inbuild. Even som it can mimic it with Single way data binding as we used above.

```html
<input type="text" [value]="text" (input)="updateValue($event)">
{{text}}
```

```javascript
//This is the initial value initailzied in the exported class scope
text = 'app';
//e here is a Input event object.
updateValue(e){
    this.text = e.target.value;
    //Gives actual value of what is typed.
    console.log(e.target.value);
}
```

The above `value` and `input` are the directives that Angular provides out of the box.

We could create our own directives as below.

```html
<input type="text" [(ngModel)]="text" />
```

`ngModel` is not a part of the basic Angular app, thus it need to be imported it in `app.module.ts` like :
`import { FormsModule } from '@angular/forms`
Also add `NgModel` to the imports array of the same file.

NgModule finally can be said as an inbuild two way databinding directive that is provided by Angular.

## ngFor

Could be used where ever we want to use iterable.

```js
export class AppComponent{
    records = [
        {
            name: 'Mehul',
            online: false
        },
        {
            name: 'Adwait',
            online: true
        }
    ]
}
```

```html
<table>
    <tr>
        <td>Sr no</td>
        <td>Name</td>
        <td>Is online</td>
    <tr>
    <tr> *ngFor= "let record of records; let myIndex = index; let evenRecord=even; let oddRecord=odd;let firstRecord=first; let lastRecord=last;" [ngClass]={odd: oddRecord, even: evenRecord}>
        <td>{{myIndex + 1}}</td>
        <td>{{record.name}}</td>
        <td>{{record.online}}</td>
    </tr>
</table>
```

The even and odd seperates even and odd records and returns a boolean value. Also first and last gives the first and the last record in the iterable.

The `[ngClass]` Applies conditional class to the element in html.

## Services

It is a singleton instance of a file that can be ingected into multiple components.

Example :
If we want to fetch data, we can create a service to do that.
Or if we want to create a login authentication then we can create a service for login.

Creating a new Service : `ng generate service records`

Example : Create a data service

```javascript
//record.service.ts class
@Injectable()
export class RecordsService{
    constructor(){}

    getData(){
        return [
            {
                name : 'Mehul,
                online: true
            },
            {
                name : 'Adwait',
                online : false
            }
        ]
    }
}


//app.component.ts

import { RecordsService } from ./

export class AppComponent{

    records = {}

    //This is type Script code where we Inject our service privatly into the constructor.
    constructor(private myFirstService : RecordsService){

    }

    //We here initialize our data from the service so that we can use it where ever we want to.
    ngOnInit(){
        this.records = this.myFirstService.getData;
    }
}

//app.module.ts

import { RecordsService } from ./serviceFileLocation

@NgModule({
    //All the stuff that we are not concerned here

    providers: [RecordsService]

    //All other things here
})
```

Service Can be specific to a component, we can inject the service to the component directly.

But most of the time we want our service to be shared by multiple component in our Angular project. To do that we add that service in our  app.module.ts

`ngOnInit()` is a life cycle hook that run only once when the component is created. Thus it becomes a perfect place for runnning code that need to be run only one like initialize our data to be used in our application components.

## HttpClient

```ts
//app.module.ts

import { HttpClientModule } from '@angular/common/http'

@NgModule({

    //Other code here

    imports: [
        BrowserModule,
        HttpClientModule
    ]

    //Other code here
})

//We can not inject the HttpClient module in our Service.

//records.service.ts

import { HttpClient } from '@angular/common/http'

//This tells that this service can have some injectable in the service like the HttpClient.
@Injectable
export class RecordsService{
    //Here we inject the service to the file
    constructor(private http: HttpClient){

    }

    //The subscribe comes from RxJs event.
    getData(){
      return this.http.get<myData>
      ('http://urlforthedataserverhere.com')
      //Rather than to subscribe here we can subscribe where we want to fetch the data when it is required.
      // .subscribe(data => {
      //   console.log('We got data ', data);
      })
    }

}

//app.component.ts

//This is an interface that provides details on how the HttpClient should retrive data.
interface myData {
  obj : Object
}

//all the codes and imports in the class remain as they should have been.
export class AppComponent {
  records = [];

  constructor(private myFirstService : RecordsSerivce){
  }

  //This is where we want ot subscribe to data rather than in the service as we want to actually fetch data when the component is created and not before that.
  ngOnInit(){
    this.myFirstService.getData().subscribe(data => {
      this.records = data.obj;
    })
  }
}

```

## Proxy Configuration

Cross Orgin Resource Sharing : Standard set of implementation how frontend can access other servers code.

This is a security implementation by browsers.

For development we need to proxy our request from angular server to our remote server.

Working flow of request send by Angular :

| Angular 4200 | --> makes an API call --> | API Server 1234 |

|Angular 4200 | --> make API call to /api/* --> webpack dev server --> | API server 1234|

How to set up the proxy server for our request :

In the `package.json` file --> under `scripts` set the value of `start` to `"ng serve --proxy-config proxyconfig.json"`. This will set the Angular developement server setting to take configuration instruction from proxyconfig.json file that we create in the root of our project.

proxyconfig.json

```json
{
  "/api":{
    "traget":"http://localhost:1234",
    "secure": false,
    "changeOrigin": true
  }
}
```

Whatever is written at the proxyConfig path is appended at the end of the traget address.

In this case we will have `http://localhost:1234/api`. So we will have to file that are to be served from the other proxyfied address will have to be placed in the folder named by the address like in our case it will be `api`. In our case the final path of the file from that was created in previous examples will be : `projectRoot/test/api/file.json` where `file.json` is the data file being served at the proxy address.

Now that we have set the proxy we can run our program to start our developer server by : `npm start`.

## Routing

Displaying different content and different pages.

Need routing for displaying large amount of content in chunks on the website, or for creating special authorized access-only pages.

Example:

1. create two components Home and Data.

`ng g c Home` and `ng g c Data`

```ts 1:50:52
//app.module.ts

import { RouterModule } from '@anfular/router'
//All other imports here

@NgModule({
  //other data here

  imports: [
    //Other imports here

    //To the router module we pass in an array of the required routes.
    /*The routes that can match multiple paths should be placed lower on the list to the routes that are more specific.
    Example /data1/data2 should be placed above /data1 as Angular will match /data1 as soon as the first match is found and serve the component for that route.
    */
    RouterModule.forRoot([
      {
        path: 'data',// localhost:4200/data
        component: DataComponent
      },
      {
        path: '',
        component: HomeComponent
      }
    ])
  ]
})
```

The html Page for the routing.

```html
<!-- Main app.component html file -->
This will always display : Anything that is outside of our router outlet tags will always display irrespecitve of which route we are on as it is indepent of the routing that we have set.
<router-outlet></router-outlet>

<!-- Home component html file-->
<p>
  Home Works!
  <a routerLink="/data">Go to Data Page</a>
</p>
```

The routerLink is a special link and our app will not be reloaded completely.

So we also see that file.json will not be loaded at the '' path, it will only load the file when we call the rout '/data', as angular does not load all the component and related files all at once.

## Login App

This is an example that gives us basic of Angular.

Following features are covered under this mini Project :

1. App Components

2. Backend validation

3. Routing

4. Route Protection

## Route Guards

Verifies whether a user is allowed to access to a route.

Methods of RouteGuard :

1. Can Activate : Will only protects one route.

2. CanActivateChild : If it is set for `/admin` will also protect all the routes that are `/admin/*`

3. CanDeactivate : Can be used to keep some route active so that the user can access it again fast.

4. Resolve : Get some data from api server before the user actually needs or sees the data.

5. CanLoad : Lazily load the component after checking the user is allowed or has permission to access the route.

Creating a guard : `ng generate guard auth`

Using the Authguard that we created

```ts
//auth.guard.ts
@Injectable()
export class AuthGuard implements CanActivate{

  constructor(private auth: AuthSerivice) {
  }

  canActivate(
    //Default code here
    //--1 Change
    //return false// If return true auth will not be applied and we can directly access the admin page.
    //As we use false as our value we cannot access the admin Component and we are redirected to the home component.

    //We will let our AuthService handle the authentication and set the boolean value for the guard.
    return this.auth.isLoggedIn;
  )
}

//app.module.ts
import { AuthGuard } from './auth.guard';

import: [
  //other code here

  RouteModule.forRoot([
    //other code here
    {
      path: 'login',
      component: LoginComponent,
      canActivate: [AuthGuard]
    }
  ])
],
//Inject it into providers to get a singleton instance of the AuthGurad to be used.
providers: [AuthGuard, /*Other providers like*/ AuthService]

//auth.service.ts
//We need an interface for the data that comes from the input stream from the http.post request. So we create an interface for that.
interface myData{
  success: boolean,
  message: string
}

@Injectable()
export class AuthService{

  //constructor
  constructor(private http: HttpClient){ }

  //This is a function but acts as a property or in simple terms we can access it like we access variables. We can see that we dont have to use () while we get the value from this function as we see above.
  //---1 Change
  // get isLoggedIn(){

  // }

  //Public property to be set from other class
  //--2 make the value private as we create setLoggedIn method to set the value for the variable.
  private loggedInStatus = false;

  //--2 Set value for loggedInStatus by using a method
  setLoggedIn(value: boolean){
    this.loggedInStatus = value;
  }

  //getter for loggedin
  get isLoggedIn(){
    return loggedInStatus;
  }

  //getUserDetails or other methods here.
  getUserDetails(username, password){
    return this.http.post<myData>('/api/auth.php',{
      username,
      password
    });
  }
}

//login.component.ts
import { Router } from '@angular/router';

export class LoginComponent implements OnInit{
  constructor(private Auth: AuthSerive, private router: Router) {}

  loginUser(event){
    //other code here

    this.auth.getUserDetails(username, password).subscribe(data=>{
      if(data.success){
        //here when the user is authenticated properly we redirect the user to admin or load the admin component.
        this.router.navigate(['admin']);
        this.Auth.setLoggedIn(true);
      }
      else{
        window.alert(data.message);
      }
    })
  }
}
```

The above code is still very insecure as the authentication code is authenticated at runtime.

### Getting data from BackEnd
