# Spring Security

## Adding Security dependencies

Once we have added the *spring-boot-starter-security* dependency to our project pom file or gradle file, spring will automatically set up a form based login page for our REST api and will ask for username and password. This is mapped at '/login' page. The username is user and password is autogenerated and logged into the console.

The password so generated is a UUID and the username is user and is stored in the memory and valid only till the application is running. The password will be changed if the application shuts down or we restart the application.

So if we run the app without any configurtion we will be taken to a form as mentioned above and we will have to login. At this point all the endpoint are locked down and we cannot access anything without logging in.

## Basic Authentication

In basic authentication the client has to send the username and password with every request.

```java
//File : src/security/ApplicationSecurityConfig
@Configuration
@EnableWebSecurity
public class ApplicationSecurityConfig extends WebSecurityConfigurerAdapter{

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizedRequests()
            //With antMathcers we specify the paths that we want in this case permit access without login as defined with permitAll
            .antMatchers("/", "index", "/css/*", "/js/*")
            .permitAll()
            .anyRequest() //Tells that we want to authenticate all the requests.
            .authenticated()
            .and()
            .httpBasic()//The way we want to set up our security
    }
}
```

This basic authentication encodes the username and password as a base64 string.

If we are in the browser, now the spring application when running will give us a pop up where we can enter a password to login. In basic auth we cannot logout as the username and password need to be send with each request and the server will check the credentials with every request.

If we want to test our app with postman we go to the Authorization and select basic auth and then enter our username and password. Postman will convert our username and password into Base64 string and add it to the Header of the request it sends.

* We can define our own user as we are till now used only the user that is by default created by the spring boot security at app initialization.

```java
//ApplicationSecurityConfig.java

//The code that was already defined in above example

/*
* The UserDetailsService is the interface that defines how we retrive our users information.
* UserDetailsService is implemented in many types of managers, and any of them can be returned. 
*/
@Override
@Bean
protected UserDetailsService userDetailsService(){

    //User should be from Spring boot security
    UserDetails annaSmithuser = User.builder()
                .username("annasmith")
                .password("password")
                .role("STUDENT") //Interpreted by spring as ROLE_STUDENT
                .build();

    //We use InMemoryUserDetailsManager as annasmith is defined in memory.
    return new InMemoryUserDetailsManager(annaSmithUser);
}

//The above code alone will not be enough though as spring will not let us have a password that is not encoded by some form of encoder.

//In this case we will use BCrypt password encoder to encode our password.

//------------------

//File : PAsswordConfig
@Configuration
public class PasswordConfig{

    //PasswordEncoder is an interface and defines an encode() method that we are interested in here. We have BCrypt password encoder that implements the PasswordEncoder interface.
    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder(10);
        //Here 10 is the strength of password encryption. We dont want it to be too high as it will increase process time and not too low.
    }
}

//File : ApplicationSecurityConfig

//We Constructor inject the Encoder instance that spring will create for us from the above defined bean.
private final PasswordEncoder passwordEncoder;

@Autowired
public ApplicationSecurityConfig(PasswordEncoderpasswordEncoder){
    this.passwordEncoder = passwordEncoder;
}

//In the UserDetailsService Method above we change
    .password(passwordEncoder.encode("password"))
//All other code remains the same.
```

### Auth Roles Or Permissions

```java
//File : ApplicationSecurityConfig
//All the code defined above 
@Override
@Bean
protected UserDetailsService userDetailsService(){

    //All the code as above exmple

    //Specify another user with Admin role
    UserDetails lindaUser = User.builder()
                                .username("linda")
                                .password(passwordEncoder.encoder("password123"))
                                .roles("ADMIN")
                                .build();
}

//Define a enum to define permissions
//File : ApplicationUserRole.enum
public enum ApplicationUserRole{
    STUDENT(Sets.newHashSet()),//The set is set to empty as student will not have any permissions.
    ADMIN(Sets.newHashSet(COURSE_READ, STUDENT_READ, STUDENT_WIRTE, COURSE_WRITE))//We Import eh enum defined below ApplicationUserPermission

    private final Set<ApplicationUserPermission> permissions;

    ApplicationUserRole(Set<ApplicationUserPermission> permissions){
        this.permissions = permissions;
    }

    //getter for this enum
    public Set<ApplicationUserPermission> getPermissions(){
        return permissions;
    }
}

//File : ApplicationUserPermission.enum
public enum ApplicationUserPermission{
    STUDENT_READ("student:read"),
    STUDENT_WRITE("student:write"),
    COURSE_READ("course:read"),
    COURSE_WIRTE("course:write")

    private final String permission;

    ApplicationUserPermission(String permission){
        this.permission = permission;
    }

    public String getPermission(){
        return permission;
    }
}

//We then attach the enums to the roles of the two users we added to ApplicationSecurityConfig.java

//For student -> annaSmithUser
.role(ApplicationUserRole.STUDENT.name())

//For Admin -> linda
.role(ApplicationUserRole.ADMIN.name())
```

> Note we add google.guava as a dependency to our pom file to 

### Role Based Authorization

* Add one more `.antMatcher("/api/**").hasRole(STUDENT.name())`. This is in addtion to the one we have added before that has `permitAll`

This will set up role based authentication.

### Permission Based Authentication
